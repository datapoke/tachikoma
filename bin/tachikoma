#!perl
# ----------------------------------------------------------------------
# tachikoma interpreter
# ----------------------------------------------------------------------
#

use strict;
use warnings;
use Tachikoma::EventFrameworks::Select;
use Tachikoma::Nodes::Router;
use Tachikoma::Nodes::TTY qw( TK_R TK_SYNC );
use Tachikoma::Nodes::Shell2;
use Tachikoma::Nodes::Responder;
use Tachikoma::Nodes::Dumper;
use Tachikoma::Nodes::Timeout;
use Tachikoma::Nodes::Shutdown;
use Tachikoma::Message qw( TYPE FROM PAYLOAD TM_BYTESTREAM TM_EOF );
use Tachikoma::Config qw( load_module );
use Getopt::Long qw( GetOptions );
use POSIX qw( isatty );

use version; our $VERSION = qv('v2.0.192');

my $home            = ( getpwuid $< )[7];
my @default_configs = (
    "$home/.tachikoma/etc/tachikoma.conf",
    '/usr/local/etc/tachikoma.conf',
);
my $config_file   = undef;
my $host          = undef;
my $port          = undef;
my $socket        = undef;
my $path          = undef;
my $line_buffered = undef;
my $scheme        = undef;
my $use_SSL       = undef;
my $seconds       = undef;
my $validate      = undef;
my $verbose       = undef;
my $debug_level   = undef;
my $debug_state   = undef;
my $help          = undef;

splice @ARGV, 1, 0, q(--) if ( @ARGV and $ARGV[0] !~ m{^-} );

my $r = GetOptions(
    'config=s'      => \$config_file,
    'host=s'        => \$host,
    'port=i'        => \$port,
    'socket=s'      => \$socket,
    'path=s'        => \$path,
    'line-buffered' => \$line_buffered,
    'scheme=s'      => \$scheme,
    'use-ssl'       => \$use_SSL,
    'timeout=i'     => \$seconds,
    'validate'      => \$validate,
    'verbose'       => \$verbose,
    'debug_level:i' => \$debug_level,
    'debug_state:i' => \$debug_state,
    'help'          => \$help,
);
my @arguments = @ARGV;
my $filename  = $arguments[0];

usage() if ( $help or not $r );
my $config = Tachikoma->configuration;
$config->load_config_file( $config_file ? $config_file : @default_configs );
Tachikoma->scheme($scheme) if ($scheme);
Tachikoma->event_framework( Tachikoma::EventFrameworks::Select->new );

my $new_server = undef;
$new_server = 'true' if ( not $host and not length $socket );
$port    //= $config->listen_sockets->[0]->{Port};
$use_SSL //= $config->listen_sockets->[0]->{use_SSL};
my $isa_tty = isatty(*STDIN);
$verbose = 'true' if ($debug_level);
$config->debug_level($debug_level);

my ($stdin,   $shell,    $tachikoma, $responder, $dumper,
    $timeout, $shutdown, $stdout,    $router,    $node
);

$stdin = Tachikoma::Nodes::TTY->filehandle( *STDIN, TK_R );
$shell = Tachikoma::Nodes::Shell2->new;
if ($new_server) {
    my $module = 'Tachikoma::Nodes::CommandInterpreter';
    load_module($module);
    $tachikoma = $module->new;
}
else {
    my $module = 'Tachikoma::Nodes::Socket';
    load_module($module);
    if ( length $socket ) {
        $tachikoma = $module->unix_client( $socket, TK_SYNC, $use_SSL );
    }
    else {
        $tachikoma = $module->inet_client( $host, $port, TK_SYNC, $use_SSL );
    }
    $tachikoma->name('_socket');
}
$responder = Tachikoma::Nodes::Responder->new;
$dumper    = Tachikoma::Nodes::Dumper->new if ( $verbose or $isa_tty );
$timeout   = Tachikoma::Nodes::Timeout->new if ($seconds);
$shutdown  = Tachikoma::Nodes::Shutdown->new;
$stdout    = Tachikoma::Nodes::TTY->filehandle( *STDOUT, TK_SYNC );
$router    = Tachikoma::Nodes::Router->new;
$node      = undef;

$router->name('_router');
$router->type('tachikoma');
$router->debug_state($debug_state);
$shell->path($path);
$timeout->arguments( $seconds * 1000 ) if ($seconds);

$node = $stdout;
attach($shutdown);
attach($timeout) if ($seconds);
if ( $verbose or $isa_tty ) {
    $shell->show_commands('true') if ( not $isa_tty );
    attach($dumper);
}
$responder->name('_responder');
$responder->shell($shell);
attach($responder);
if ($new_server) {
    $node = $router;
    $tachikoma->name('_command_interpreter');
}
else {
    $tachikoma->debug_state($debug_state);
    $tachikoma->on_EOF('die');
}
attach($tachikoma);
$shell->want_reply($verbose);
$shell->validate($validate);
attach($shell);
$Tachikoma::Now       = time;
$Tachikoma::Right_Now = $Tachikoma::Now;

if ( length $filename ) {
    my @values = @arguments;
    $config->{var}->{$_} = $values[$_] for ( 1 .. $#values );
    $config->{var}->{q(0)} = shift @values;
    $config->{var}->{q(@)}  = join q( ), @values;
    $config->{var}->{q(_C)} = scalar @values;
    my @lines = ();
    my $fh;
    open $fh, '<', $filename or die "ERROR: can't open $filename: $!\n";
    push @lines, $_ while (<$fh>);
    close $fh or die $!;

    for my $line (@lines) {
        my $message = Tachikoma::Message->new;
        $message->[TYPE]    = TM_BYTESTREAM;
        $message->[FROM]    = '_stdin';
        $message->[PAYLOAD] = $line;
        $shell->fill($message) if ( not Tachikoma->shutting_down );
    }
    if ( not $shell->is_attached and not $config->secure_level ) {
        my $message = Tachikoma::Message->new;
        $message->[TYPE] = TM_EOF;
        $message->[FROM] = '_stdin';
        $shell->fill($message) if ( not Tachikoma->shutting_down );
    }
}
else {
    $shell->is_attached('true');
}
if ( $shell->is_attached ) {
    $stdin->name('_stdin');
    $stdin->buffer_mode('line-buffered');
    if ($isa_tty) {
        $stdin->use_readline('true');
        $shell->want_reply('true');
        $shell->isa_tty('true');
    }
    attach($stdin);
}

sub attach {
    my $next = shift;
    $next->sink($node);
    $node = $next;
    return;
}

if ( not $filename and $isa_tty ) {
    $shell->prompt;
    $shell->get_completions if ( $stdin->use_readline );
}

$router->drain;

# makes sure readline resets the display:
if ($isa_tty) {
    $stdin->close_filehandle;
    print "\n" if ( $shell->last_prompt );
}

if ( $shell->errors
    and ( $validate or ( length $filename or not $isa_tty ) ) )
{
    print $filename ? "$filename " : 'stdin ', "had compilation errors.\n";
    exit 1;
}
print length $filename ? "$filename " : q(), "syntax OK\n" if ($validate);

sub usage {
    print "Usage:\n"
        . "tachikoma [ --config=<file>                   ]\n"
        . "          [ --include=<file>                  ]\n"
        . "          [ --host=<host>                     ]\n"
        . "          [ --port=<port>                     ]\n"
        . "          [ --socket=<file>                   ]\n"
        . "          [ --path=<node>                     ]\n"
        . "          [ --line-buffered                   ]\n"
        . "          [ --use-ssl                         ]\n"
        . "          [ --scheme=<rsa,rsa-sha256,ed25519> ]\n"
        . "          [ --timeout=<seconds>               ]\n"
        . "          [ --validate                        ]\n"
        . "          [ --verbose                         ]\n"
        . "          [ --help                            ]\n"
        . "          [ <file>                            ]\n";
    exit 1;
}
