#!/usr/bin/perl
# ----------------------------------------------------------------------
# fetch
# ----------------------------------------------------------------------
#
# $Id$
#

use strict;
use warnings;
use Tachikoma::Nodes::Table;
require '/usr/local/etc/tachikoma.conf';
use JSON -support_by_pp;

my ( $topic, $field, $key, $verbose ) = @ARGV;
die "no topic\n" if ( not $topic );
die "no field\n" if ( not $field );
die "no key\n"   if ( not length $key );
my $table = Tachikoma::Nodes::Table->new;
$table->host('localhost');
$table->port(5100);
$table->topic($topic);
$table->field($field);
my $json = JSON->new;
$json->canonical(1);
$json->pretty(1);
$json->allow_blessed(1);
$json->convert_blessed(0);
my $output  = undef;
my $value   = undef;
my $payload = $table->fetch($key);

if ($payload) {
    my ( $partition, $offset ) = split m{:}, $payload, 2;
    $value = $table->fetch_offset( $partition, $offset );
}
if ( ref $value eq 'Tachikoma::Message' ) {
    $output = $verbose ? &dump_message($value) : $value->payload;
}
else {
    $output = $value;
}
if ( ref $output ) {
    print $json->utf8->encode($output);
}
elsif ( defined $output ) {
    print $output;
}

sub dump_message {
    my $message = shift;
    return {
        type      => $message->type_as_string,
        timestamp => $message->timestamp,
        partition => $message->from,
        offset    => $message->id,
        key       => $message->stream,
        payload   => $message->payload
    };
}
