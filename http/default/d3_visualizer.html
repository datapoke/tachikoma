<!DOCTYPE html>
<html>

<head>
  <title>D3 Visualizer</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      background-color: #111;
      color: #faf;
    }
    circle {
      fill: #afa;
    }
    .links line {
      stroke-opacity: 0.6;
    }
    .nodes circle {
      stroke: #fff;
      stroke-width: 1.5px;
    }
    body {
      margin: 0;
      padding: 8px;
      box-sizing: border-box;
      max-width: 100vw;
      max-height: 100dvh;
      overflow-x: hidden;
      transform: translateZ(0);
      will-change: transform;
    }
    svg {
      max-width: 100%;
      display: block;
      height: auto;
    }
    @view-transition {
      navigation: auto;
    }
    .sink {
      filter: drop-shadow(0px 1px 10px #6d6);
    }
    .owner {
      filter: drop-shadow(0px 1px 10px #88f);
    }
    .edge {
      filter: drop-shadow(0px 1px 10px #d66);
    }
  </style>
</head>

<body>
  <svg></svg>
  <script>
    let svg = d3.select("svg")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    let zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on("zoom", zoomed);
    let decayFactor = 0.2;
    let alphaFactor = 0.5;

    svg.call(zoom);

    let g = svg.append("g"),
        link = g.append("g").attr("class", "links").selectAll(".link"),
        node = g.append("g").attr("class", "nodes").selectAll(".node");

    let simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) { return d.id; }))
        .force("charge", d3.forceManyBody().strength(-1))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .velocityDecay(decayFactor);

    let previousData = null;
    let previousTransformedData = null;
    let previousNodeCount = 0;

    function transformData(data) {
        let nodes = data.map(function (d) {
            let previousNode = previousData ? previousData.find(function (p) { return p.name === d.name; }) : null;
            let messageRate = previousNode ? d.counter - previousNode.counter : 0;
            return { name: d.name, sink: d.sink, edge: d.edge, owner: d.owner, messageRate: messageRate };
        });

        let links = [];
        data.forEach(function (d) {
            let sourceIndex = nodes.findIndex(function (e) { return e.name === d.name; });
            let targetIndex = nodes.findIndex(function (e) { return e.name === d.sink; });
            let edgeIndex = nodes.findIndex(function (e) { return e.name === d.edge; });
            if (sourceIndex === -1) return;
            if (targetIndex !== -1) {
                links.push({
                    source: nodes[sourceIndex],
                    target: nodes[targetIndex],
                    edge: 0,
                    owner: 0
                });
            }
            if (edgeIndex !== -1) {
                links.push({
                    source: nodes[sourceIndex],
                    target: nodes[edgeIndex],
                    edge: 1,
                    owner: 0
                });
            }
            if (!Array.isArray(d.owner)) {
                let ownerIndex = nodes.findIndex(function (e) { return e.name === d.owner; });
                if (ownerIndex !== -1) {
                    links.push({
                        source: nodes[sourceIndex],
                        target: nodes[ownerIndex],
                        edge: 0,
                        owner: 1
                    });
                }
            } else {
                for (var i = 0; i < d.owner.length; i++) {
                    let owner = typeof d.owner[i] === 'string' ? d.owner[i].split('/')[0] : d.owner[i];
                    let ownerIndex = nodes.findIndex(function (e) { return e.name === owner; });
                    if (ownerIndex !== -1) {
                        links.push({
                            source: nodes[sourceIndex],
                            target: nodes[ownerIndex],
                            edge: 0,
                            owner: 1
                        });
                    }
                }
            }
        });

        return {
            nodes: nodes,
            links: links
        };
    }

    let sizeScale     = d3.scaleLog().range([5, 10]);
    let strengthScale = d3.scaleLog().range([100, 200]);

    function updateGraph() {
        let params = new URLSearchParams(window.location.search);
        let service = params.get('service');
        d3.json("/v/" + service)
            .then(function (data) {
                let transformedData = transformData(data);

                // if the node count is unchanged, only update the message rate
                if (previousNodeCount !== transformedData.nodes.length) {
                    decayFactor = 0.2; // reset decay when node count changes
                    alphaFactor = 0.5; // reset alpha when node count changes
                    link = link.data(transformedData.links, function (d) { return d.source.id + "-" + d.target.id; });
                    link.exit().remove();
                    link = link.enter().append("path")
                        .attr("fill", "none")
                        .attr("stroke", function (d) {
                            return d.edge ? "#e55" : d.owner ? "#77d" : "#8c8";
                        })
                        .classed("sink", function (d) { return ! d.owner && ! d.edge; })
                        .classed("owner", function (d) { return d.owner && ! d.edge; })
                        .classed("edge", function (d) { return d.edge; })
                        .merge(link);

                    node = node.data(transformedData.nodes, function (d) { return d.id; });
                    node.exit().remove();
                    let nodeEnter = node.enter().append("circle")
                        .attr("r", function (d) { return sizeScale(1 + d.messageRate); })
                        .style("fill", function (d) {
                            if (d.edge) return "#f55"; // nodes that have edges
                            else if (d.owner) return "#77f"; // nodes that have owners
                            else return "#6e6"; // nodes that have sinks
                        })
                        .classed("sink", function (d) { return ! d.owner && ! d.edge; })
                        .classed("owner", function (d) { return d.owner && ! d.edge; })
                        .classed("edge", function (d) { return d.edge; })
                        .call(d3.drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended));

                    // Add tooltips
                    nodeEnter.append("title")
                        .text(function (d) { return d.name; });

                    node = nodeEnter.merge(node);

                    simulation
                        .nodes(transformedData.nodes)
                        .on("tick", ticked);
                    simulation.force("link")
                        .links(transformedData.links);
                    simulation.alpha(1).restart();
                }
                else {
                    // Update the message rate
                    d3.selectAll("circle")
                        .each(function (d, i) {
                            d.messageRate = transformedData.nodes[i].messageRate;
                        })
                        .attr("r", function (d) { return sizeScale(1 + d.messageRate); });
                    // Gradually slow the velocity
                    forceFactor = getForce();
                    if ( decayFactor < 0.8 ) {
                        decayFactor += 0.01 * forceFactor;
                    }
                    else if ( alphaFactor > 0.2 ) {
                        alphaFactor -= 0.01 * forceFactor;
                    }
                    // Update charge strength based on new messageRate strengthScale to prevent nodes from overlapping
                    simulation.force("charge",
                        d3.forceManyBody()
                            .strength(function (d) { return -1.0 * forceFactor * strengthScale(1 + d.messageRate); })
                    ).velocityDecay(decayFactor);
                    simulation.alphaTarget(alphaFactor).restart();
                }

                // Store the data string for the next update
                previousData = data;
                previousTransformedData = transformedData;
                previousNodeCount = transformedData.nodes.length;
            })
            .catch(function (error) {
                console.log("Error:", error);
            });
    }

    function ticked() {
        link
            .attr("d", function (d) {
                if (d.owner) {
                    // Draw a Bezier curve for links between owner nodes
                    let dx = d.target.x - d.source.x,
                        dy = d.target.y - d.source.y,
                        dr = Math.sqrt(dx * dx + dy * dy);
                    return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                } else {
                    // Draw a straight line for other links
                    return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
                }
            });

        node
            .attr("cx", function (d) { return d.x; })
            .attr("cy", function (d) { return d.y; });

    }

    function zoomed(event) {
        g.attr("transform", event.transform);
    }

    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(alphaFactor).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function resize() {
        let width = window.innerWidth,
            height = window.innerHeight;

        svg.attr("width", width)
            .attr("height", height);

        simulation.force("center", d3.forceCenter(width / 2, height / 2));
    }

    function getForce() {
        let params = new URLSearchParams(window.location.search);
        let factor = params.get('force') || 1.0;
        return factor;
    }

    function initialZoom() {
        let params = new URLSearchParams(window.location.search);
        let initialZoom = params.get('zoom') || 1.0;
        zoom.scaleTo(svg, initialZoom * height / 1080);
    }

    let resizeTimeout;
    window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        resize();
    }, 200); // adjust delay as needed
    });

    setInterval(updateGraph, 5000);
    initialZoom();
    updateGraph();
  </script>
</body>
</html>
