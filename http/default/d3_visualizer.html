<!DOCTYPE html>
<html>

<head>
  <title>D3 Visualizer</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      background-color: #111;
      color: #faf;
    }
    circle {
      fill: #afa;
    }
    .links line {
      stroke-opacity: 0.6;
    }
    .nodes circle {
      stroke: #fff;
      stroke-width: 1.5px;
    }
    body {
      margin: 0;
      padding: 8px;
      box-sizing: border-box;
      max-width: 100vw;
      max-height: 100dvh;
      overflow-x: hidden;
      transform: translateZ(0);
      will-change: transform;
    }
    svg {
      max-width: 100%;
      display: block;
      height: auto;
    }
    @view-transition {
      navigation: auto;
    }

    /* Apply different filters to each group */
    .sink-links {
      filter: drop-shadow(0px 0px 10px #ac8);
    }
    .owner-links {
      filter: drop-shadow(0px 0px 10px #8ac);
    }
    .edge-links {
      filter: drop-shadow(0px 0px 10px #c8a);
    }
    .sink-nodes {
      filter: drop-shadow(0px 0px 10px #8f8);
    }
    .owner-nodes {
      filter: drop-shadow(0px 0px 10px #88f);
    }
    .edge-nodes {
      filter: drop-shadow(0px 0px 10px #f88);
    }
  </style>
</head>

<body>
  <svg></svg>
  <script>
    let svg = d3.select("svg")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    let zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on("zoom", zoomed);

    svg.call(zoom);

    let g = svg.append("g"),
    // Create LINK groups first (so they're drawn behind)
    sinkLinkGroup = g.append("g").attr("class", "sink-links"),
    ownerLinkGroup = g.append("g").attr("class", "owner-links"),
    edgeLinkGroup = g.append("g").attr("class", "edge-links"),
    // Create NODE groups after (so they're drawn on top)
    sinkNodeGroup = g.append("g").attr("class", "sink-nodes"),
    ownerNodeGroup = g.append("g").attr("class", "owner-nodes"), 
    edgeNodeGroup = g.append("g").attr("class", "edge-nodes"),
    // Selections for nodes and links
    sinkNodes = sinkNodeGroup.selectAll(".sink-node"),
    sinkLinks = sinkLinkGroup.selectAll(".sink-link"),
    ownerNodes = ownerNodeGroup.selectAll(".owner-node"),
    ownerLinks = ownerLinkGroup.selectAll(".owner-link"),
    edgeNodes = edgeNodeGroup.selectAll(".edge-node"),
    edgeLinks = edgeLinkGroup.selectAll(".edge-link");

    let decayFactor = 0.1;
    let alphaFactor = 0.9;
    let simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) { return d.id; }))
        .force("charge", d3.forceManyBody().strength(-1))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .velocityDecay(decayFactor);

    let previousData = null;
    let previousTransformedData = null;
    let previousNodeCount = 0;
    let previousNodeMap = new Map();
    let sizeScale = d3.scaleLog().range([5, 10]);
    let strengthScale = d3.scaleLog().range([100, 200]);
    let updateQueue = [];
    let isProcessingUpdates = false;
    let request_type = "/full";
    let response_type = "";

    function transformData(data) {
        let nodes = data.map(function (d, idx) {
            let previousNode = previousData ? previousData[idx] : null;
            let messageRate = previousNode ? d.counter - previousNode.counter : 0;
            let name = previousNode ? previousNode.name : d.name;
            return { id: idx, name: name, sink: d.sink, edge: d.edge, owner: d.owner, messageRate: messageRate };
        });

        let links = [];
        data.forEach(function (d, did) {
            if (did === -1) return;
            if (d.sink !== -1) {
                links.push({
                    source: nodes[did],
                    target: nodes[d.sink],
                    sink: 1,
                    edge: 0,
                    owner: 0
                });
            }
            if (d.edge !== -1) {
                links.push({
                    source: nodes[did],
                    target: nodes[d.edge],
                    sink: 0,
                    edge: 1,
                    owner: 0
                });
            }
            if (!Array.isArray(d.owner)) {
                if (d.owner !== -1) {
                    links.push({
                        source: nodes[did],
                        target: nodes[d.owner],
                        sink: 0,
                        edge: 0,
                        owner: 1
                    });
                }
            } else {
                for (var i = 0; i < d.owner.length; i++) {
                    links.push({
                        source: nodes[did],
                        target: nodes[d.owner[i]],
                        sink: 0,
                        edge: 0,
                        owner: 1
                    });
                }
            }
        });

        return {
            nodes: nodes,
            links: links
        };
    }

    function updateGraph() {
        let params = new URLSearchParams(window.location.search);
        let service = params.get('service');
        
        // Use fetch instead of d3.json for better control
        fetch("/v/" + service + request_type)
            .then(response => response.json())
            .then(function (data) {
                // Queue the update instead of doing it immediately
                updateQueue.push({ response_type: response_type, data: data });
                if (!isProcessingUpdates) {
                    processUpdateQueue();
                }
            })
            .catch(function (error) {
                console.log("Error:", error);
            });
    }

    function processUpdateQueue() {
        if (updateQueue.length === 0) {
            isProcessingUpdates = false;
            return;
        }
        
        isProcessingUpdates = true;
        let data = updateQueue.shift();
        
        // Use requestIdleCallback to process updates when browser is idle
        if (window.requestIdleCallback) {
            requestIdleCallback(() => processUpdate(data), { timeout: 100 });
        } else {
            // Fallback for browsers without requestIdleCallback
            setTimeout(() => processUpdate(data), 0);
        }
    }

    function processUpdate(queued) {
        let transformedData = transformData(queued.data);

        if (previousNodeCount !== transformedData.nodes.length) {
            if ( queued.response_type === "/brief" ) {
                request_type = "/full";
                return;
            }
            processMajorUpdate(transformedData);
        } else {
            // For minor updates, do them quickly
            processMinorUpdate(transformedData);
        }
        
        // Store the data for the next update
        previousData = queued.data;
        previousTransformedData = transformedData;
        previousNodeCount = transformedData.nodes.length;
        
        // Continue processing queue
        if (window.requestIdleCallback) {
            requestIdleCallback(() => processUpdateQueue(), { timeout: 50 });
        } else {
            setTimeout(processUpdateQueue, 0);
        }
    }

    function processMajorUpdate(transformedData) {
        request_type = "/brief";
        decayFactor = 0.1;
        alphaFactor = 0.9;
        
        // Separate data by type
        let sinkLinkData = transformedData.links.filter(d => d.sink);
        let ownerLinkData = transformedData.links.filter(d => d.owner);
        let edgeLinkData = transformedData.links.filter(d => d.edge);
        
        let sinkNodeData = transformedData.nodes.filter(d => d.owner === -1 && d.edge === -1);
        let ownerNodeData = transformedData.nodes.filter(d => d.owner !== -1 && d.edge === -1);
        let edgeNodeData = transformedData.nodes.filter(d => d.edge !== -1);
        
        sinkLinks = sinkLinks.data(sinkLinkData, d => d.source.id + "-" + d.target.id);
        sinkLinks.exit().remove();
        let sinkLinkEnter = sinkLinks.enter().append("path")
            .attr("fill", "none")
            .attr("stroke", "#ac8")
            .classed("sink-link", true);
        sinkLinks = sinkLinkEnter.merge(sinkLinks);

        ownerLinks = ownerLinks.data(ownerLinkData, d => d.source.id + "-" + d.target.id);
        ownerLinks.exit().remove();
        let ownerLinkEnter = ownerLinks.enter().append("path")
            .attr("fill", "none")
            .attr("stroke", "#8ac")
            .classed("owner-link", true);
        ownerLinks = ownerLinkEnter.merge(ownerLinks);

        edgeLinks = edgeLinks.data(edgeLinkData, d => d.source.id + "-" + d.target.id);
        edgeLinks.exit().remove();
        let edgeLinkEnter = edgeLinks.enter().append("path")
            .attr("fill", "none")
            .attr("stroke", "#c8a")
            .classed("edge-link", true);
        edgeLinks = edgeLinkEnter.merge(edgeLinks);

        sinkNodes = sinkNodes.data(sinkNodeData, d => d.id);
        sinkNodes.exit().remove();
        let sinkEnter = sinkNodes.enter().append("circle")
            .attr("r", d => sizeScale(1 + d.messageRate))
            .style("fill", "#8f8")
            .classed("sink", true)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));
        sinkEnter.append("title").text(d => d.name);
        sinkNodes = sinkEnter.merge(sinkNodes);

        ownerNodes = ownerNodes.data(ownerNodeData, d => d.id);
        ownerNodes.exit().remove();
        let ownerEnter = ownerNodes.enter().append("circle")
            .attr("r", d => sizeScale(1 + d.messageRate))
            .style("fill", "#88f")
            .classed("owner", true)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));
        ownerEnter.append("title").text(d => d.name);
        ownerNodes = ownerEnter.merge(ownerNodes);

        edgeNodes = edgeNodes.data(edgeNodeData, d => d.id);
        edgeNodes.exit().remove();
        let edgeEnter = edgeNodes.enter().append("circle")
            .attr("r", d => sizeScale(1 + d.messageRate))
            .style("fill", "#f88")
            .classed("edge", true)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));
        edgeEnter.append("title").text(d => d.name);
        edgeNodes = edgeEnter.merge(edgeNodes);
        let allNodes = [...sinkNodeData, ...ownerNodeData, ...edgeNodeData];
        let allLinks = [...sinkLinkData, ...ownerLinkData, ...edgeLinkData];
        
        simulation
            .nodes(allNodes)
            .on("tick", ticked);
        simulation.force("link")
            .links(allLinks);
        simulation.alpha(1).restart();
    }

    function processMinorUpdate(transformedData) {
        // Create a map for O(1) lookups instead of O(n) find() calls
        let newNodeMap = new Map(transformedData.nodes.map(n => [n.id, n]));
        let changedNodes = [];
        
        // Only identify nodes that actually changed
        for (let [id, newNode] of newNodeMap) {
            let oldNode = previousNodeMap.get(id);
            if (!oldNode || oldNode.messageRate !== newNode.messageRate) {
                changedNodes.push(newNode);
            }
        }
        
        // Only update nodes that actually changed - batch by type
        if (changedNodes.length > 0) {
            let changedNodeMap = new Map(changedNodes.map(n => [n.id, n]));
            
            // Update sink nodes that changed
            sinkNodes.each(function(d) {
                let updated = changedNodeMap.get(d.id);
                if (updated) {
                    d.messageRate = updated.messageRate;
                    d3.select(this).attr("r", sizeScale(1 + d.messageRate));
                }
            });
            
            // Update owner nodes that changed
            ownerNodes.each(function(d) {
                let updated = changedNodeMap.get(d.id);
                if (updated) {
                    d.messageRate = updated.messageRate;
                    d3.select(this).attr("r", sizeScale(1 + d.messageRate));
                }
            });
            
            // Update edge nodes that changed
            edgeNodes.each(function(d) {
                let updated = changedNodeMap.get(d.id);
                if (updated) {
                    d.messageRate = updated.messageRate;
                    d3.select(this).attr("r", sizeScale(1 + d.messageRate));
                }
            });
        }
        
        // Cache the new data for next comparison
        previousNodeMap = newNodeMap;
        
        // Keep existing force update logic
        let forceFactor = getForce();
        if (decayFactor < 0.7) {
            decayFactor += 0.1 * forceFactor;
        } else if (alphaFactor > 0.3) {
            alphaFactor -= 0.1 * forceFactor;
        }
        
        simulation.force("charge",
            d3.forceManyBody()
                .strength(function (d) { return -1.0 * forceFactor * strengthScale(1 + d.messageRate); })
        ).velocityDecay(decayFactor);
        simulation.alphaTarget(alphaFactor).restart();
    }


    function ticked() {
        // Update all link groups
        sinkLinks
            .attr("d", function (d) {
                return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
            });
    
        ownerLinks
            .attr("d", function (d) {
                // Draw a Bezier curve for owner links
                let dx = d.target.x - d.source.x,
                    dy = d.target.y - d.source.y,
                    dr = Math.sqrt(dx * dx + dy * dy);
                return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
            });
    
        edgeLinks
            .attr("d", function (d) {
                return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
            });

        // Update all node groups
        sinkNodes
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);
    
        ownerNodes
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);
    
        edgeNodes
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

    }

    function zoomed(event) {
        g.attr("transform", event.transform);
    }

    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(alphaFactor).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function resize() {
        let width = window.innerWidth,
            height = window.innerHeight;

        svg.attr("width", width)
            .attr("height", height);

        simulation.force("center", d3.forceCenter(width / 2, height / 2));
    }

    function getForce() {
        let params = new URLSearchParams(window.location.search);
        let factor = params.get('force') || 1.0;
        return factor;
    }

    function initialZoom() {
        let params = new URLSearchParams(window.location.search);
        let initialZoom = params.get('zoom') || 1.0;
        zoom.scaleTo(svg, initialZoom * height / 1080);
    }

    document.addEventListener('keydown', function(e) {
        if (e.key === ' ') {
        }
    });

    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            resize();
        }, 200); // adjust delay as needed
    });

    setInterval(updateGraph, 10000);
    initialZoom();
    updateGraph();
  </script>
</body>
</html>
